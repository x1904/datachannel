package protocol

import (
	"testing"
)

type testError struct {
	Data []byte
	Err  error
}
type testOK struct {
	Data []byte
	V    interface{}
}

func TestProtocol_Error(t *testing.T) {
	tests := map[string]testError{
		"error_null":           testError{nil, ErrBufferNull},
		"error_short":          testError{[]byte{}, ErrBufferTooShort},
		"error_type":           testError{[]byte{0xFF}, ErrInvalidType},
		"error_short_metadata": testError{[]byte{0x2, 0x2}, ErrBufferTooShort},
		"error_short_metadata_payload": testError{
			[]byte{
				0x02,
				0x03,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0x00, 0x00, 0x00, 0x02,
			},
			ErrPayloadTooShort,
		},
		"error_datatype": testError{
			[]byte{
				0x02,
				0xBB,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xAA, 0xAA, 0xAA, 0xAA,
			}, ErrInvalidDataType},
	}

	for name, test := range tests {
		_, err := Unmarshal(test.Data)
		if err != test.Err {
			t.Errorf("[%s] Want:%v Expect:%v", name, test.Err, err)
		}
	}
}

func generateNameFile(name string) [32]byte {
	ret := [32]byte{}
	copy(ret[:], name)
	return ret

}
func TestProtocol_OK(t *testing.T) {
	tests := map[string]testOK{
		"ok_json": testOK{
			Data: []byte{
				0x2,
				0x1,
				'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e',
				'_', 'j', 's', 'o', 'n', 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeJSON,
				Name: generateNameFile("filename_json"),
			},
		},
		"ok_bin32": testOK{
			Data: []byte{
				0x2,
				0x2,
				'b', 'i', 'n', 'a', 'r', 'y', '3', '2',
				'e', 'l', 'f', 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeBIN32,
				Name: generateNameFile("binary32elf"),
			},
		},
		"ok_bin64": testOK{
			Data: []byte{
				0x2,
				0x3,
				'b', 'i', 'n', 'a', 'r', 'y', '6', '4',
				'e', 'l', 'f', 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeBIN64,
				Name: generateNameFile("binary64elf"),
			},
		},
		"ok_raw": testOK{
			Data: []byte{
				0x2,
				0x4,
				'r', 'a', 'w', 'd', 'a', 't', 'a', 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeRAW,
				Name: generateNameFile("rawdata"),
			},
		},
		"ok_name": testOK{
			Data: []byte{
				0x2,
				0x4,
				0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00,
				0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeRAW,
				Name: [32]byte{
					0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x04, 0x00,
					0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
				},
				Len: 0,
			},
		},
		"ok_raw_struct": testOK{
			Data: []byte{
				0x2,
				0x4,
				'r', 'a', 'w', 'd', 'a', 't', 'a', '2',
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x04,
				0x1, 0x2, 0x3, 0x4,
			},
			V: MetaData{
				Type:    DataTypeRAW,
				Name:    generateNameFile("rawdata2"),
				Len:     4,
				Payload: []byte{0x1, 0x2, 0x3, 0x4},
			},
		},
	}

	for name, test := range tests {
		header, err := Unmarshal(test.Data)
		if err != nil {
			t.Errorf("[%s] Want:null Expect:%v", name, err)
			continue
		}

		if header.Data.(MetaData).Type != test.V.(MetaData).Type ||
			header.Data.(MetaData).Name != test.V.(MetaData).Name ||
			header.Data.(MetaData).Len != test.V.(MetaData).Len {
			t.Errorf("[%s]\nWant:  %v\nExpect:%v",
				name,
				test.V.(MetaData),
				header.Data.(MetaData),
			)
		}
	}
}
