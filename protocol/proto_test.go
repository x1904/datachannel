package protocol

import (
	"bytes"
	"testing"
)

type test struct {
	Data []byte
	Err  error
	V    interface{}
}

func TestProtocol_Unmarshal_KO(t *testing.T) {
	tests := map[string]test{
		"error_null":           test{nil, ErrBufferNull, nil},
		"error_short":          test{[]byte{}, ErrBufferTooShort, nil},
		"error_type":           test{[]byte{0xFF}, ErrInvalidType, nil},
		"error_short_metadata": test{[]byte{0x2, 0x2}, ErrBufferTooShort, nil},
		"error_short_metadata_payload": test{
			[]byte{
				0x02,
				0x03,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0x00, 0x00, 0x00, 0x02,
			},
			ErrPayloadTooShort,
			nil,
		},
		"error_datatype": test{
			[]byte{
				0x02,
				0xBB,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xAA, 0xAA, 0xAA, 0xAA,
			},
			ErrInvalidDataType,
			nil,
		},
	}

	for name, test := range tests {
		_, err := Unmarshal(test.Data)
		if err != test.Err {
			t.Errorf("[%s] Want:%v Expect:%v", name, test.Err, err)
		}
	}
}
func TestProtocol_Unmarshal_OK(t *testing.T) {
	tests := map[string]test{
		"ok_json": test{
			Data: []byte{
				0x2,
				0x1,
				'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e',
				'_', 'j', 's', 'o', 'n', 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeJSON,
				Name: "filename_json",
			},
		},
		"ok_bin32": test{
			Data: []byte{
				0x2,
				0x2,
				'b', 'i', 'n', 'a', 'r', 'y', '3', '2',
				'e', 'l', 'f', 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeBIN32,
				Name: "binary32elf",
			},
		},
		"ok_bin64": test{
			Data: []byte{
				0x2,
				0x3,
				'b', 'i', 'n', 'a', 'r', 'y', '6', '4',
				'e', 'l', 'f', 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeBIN64,
				Name: "binary64elf",
			},
		},
		"ok_raw": test{
			Data: []byte{
				0x2,
				0x4,
				'r', 'a', 'w', 'd', 'a', 't', 'a', 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeRAW,
				Name: "rawdata",
			},
		},
		"ok_name": test{
			Data: []byte{
				0x2,
				0x4,
				'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
				'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
				'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
				'y', 'z', '0', '1', '2', '3', '4', 0,
				0x00, 0x00, 0x00, 0x00,
			},
			V: MetaData{
				Type: DataTypeRAW,
				Name: "abcdefghijklmnopqrstuvwxyz01234",
			},
		},
		"ok_raw_struct": test{
			Data: []byte{
				0x2,
				0x4,
				'r', 'a', 'w', 'd', 'a', 't', 'a', '2',
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x04,
				0x1, 0x2, 0x3, 0x4,
			},
			V: MetaData{
				Type:    DataTypeRAW,
				Name:    "rawdata2",
				Payload: []byte{0x1, 0x2, 0x3, 0x4},
			},
		},
	}

	for name, test := range tests {
		header, err := Unmarshal(test.Data)
		if err != nil {
			t.Errorf("[%s] Want:null Expect:%v", name, err)
			continue
		}

		if header.Data.(MetaData).Type != test.V.(MetaData).Type ||
			header.Data.(MetaData).Name != test.V.(MetaData).Name ||
			len(header.Data.(MetaData).Payload) != len(test.V.(MetaData).Payload) {
			t.Errorf("[%s]\nWant:  %v\nExpect:%v",
				name,
				test.V.(MetaData),
				header.Data.(MetaData),
			)
		}
	}
}

func TestProtocol_Marshal_KO(t *testing.T) {
	tests := map[string]test{
		"ko_type_invalid": test{
			Data: nil,
			V: &Header{
				Type: 0, // invalid type
				Data: nil,
			},
		},
		"ko_data_null": test{
			Data: []byte{TypeData},
			V: &Header{
				Type: TypeData,
				Data: nil,
			},
		},
		"ko_datatype_invalid": test{
			Data: []byte{TypeData},
			V: &Header{
				Type: TypeData,
				Data: MetaData{},
			},
		},
		"ko_data_len_equal_0": test{
			Data: []byte{
				TypeData,
				DataTypeBIN32,
				'l', 's', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: &Header{
				Type: TypeData,
				Data: MetaData{
					Type: DataTypeBIN32,
					Name: "ls",
				},
			},
		},
		"ko_data_data_null": test{
			Data: []byte{
				TypeData,
				DataTypeBIN32,
				'l', 's', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: &Header{
				Type: TypeData,
				Data: MetaData{
					Type: DataTypeBIN32,
					Name: "ls",
				},
			},
		},
		"ko_data_len_no_equal_payload": test{
			Data: []byte{
				TypeData,
				DataTypeBIN32,
				'l', 's', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
			V: &Header{
				Type: TypeData,
				Data: MetaData{
					Type: DataTypeBIN32,
					Name: "ls",
				},
			},
		},
	}
	for name, test := range tests {
		header := test.V.(*Header).Marshal()

		if !bytes.Equal(header, test.Data) {
			t.Errorf("[%s]\nWant:  %v\nExpect:%v",
				name,
				test.Data,
				header,
			)
		}
	}
}
func TestProtocol_Marshal_OK(t *testing.T) {
	tests := map[string]test{
		"ok_marshal": test{
			Data: []byte{
				TypeData,
				uint8(DataTypeRAW),
				'l', 's', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x04,
				0xDA, 0xED, 0xBE, 0xEF,
			},
			V: &Header{
				Type: TypeData, // invalid type
				Data: MetaData{
					Type:    DataTypeRAW,
					Name:    "ls",
					Payload: []byte{0xDA, 0xED, 0xBE, 0xEF},
				},
			},
		},
	}
	for name, test := range tests {
		header := test.V.(*Header).Marshal()

		if !bytes.Equal(header, test.Data) {
			t.Errorf("[%s]\nWant:  %v\nExpect:%v",
				name,
				test.Data,
				header,
			)
		}
	}
}

